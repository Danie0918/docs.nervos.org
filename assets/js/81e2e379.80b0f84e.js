"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7702],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>d});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),p=c(a),d=i,m=p["".concat(l,".").concat(d)]||p[d]||u[d]||r;return a?n.createElement(m,s(s({ref:t},h),{},{components:a})):n.createElement(m,s({ref:t},h))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},1566:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var n=a(7462),i=a(3366),r=(a(7294),a(3905)),s=["components"],o={id:"upgradability",title:"Upgradable CKB Contracts\u2014Why And How"},l=void 0,c={unversionedId:"essays/upgradability",id:"essays/upgradability",title:"Upgradable CKB Contracts\u2014Why And How",description:"In the blockchain space, there's a pair of issues that everyone has to pick sides: upgradability vs determinism.",source:"@site/docs/essays/upgradability.md",sourceDirName:"essays",slug:"/essays/upgradability",permalink:"/docs/essays/upgradability",draft:!1,editUrl:"https://github.com/nervosnetwork/docs-new/tree/develop/website/docs/essays/upgradability.md",tags:[],version:"current",frontMatter:{id:"upgradability",title:"Upgradable CKB Contracts\u2014Why And How"},sidebar:"Essays",previous:{title:"The Back-of-Envelope Calculation of the Transaction Confirmation Number",permalink:"/docs/essays/tx-confirmation"}},h={},u=[{value:"<strong>Write A Unique Type Script</strong>",id:"write-a-unique-type-script",level:2},{value:"<strong>Resolving Contracts in CKB Transaction</strong>",id:"resolving-contracts-in-ckb-transaction",level:2},{value:"<strong>Putting Everything Together</strong>",id:"putting-everything-together",level:2},{value:"<strong>Trust Issue</strong>",id:"trust-issue",level:2},{value:"<strong>Determinism Property A</strong>",id:"determinism-property-a",level:3},{value:"<strong>Ownership</strong>",id:"ownership",level:4},{value:"<strong>Availability</strong>",id:"availability",level:4},{value:"<strong>Determinism Property B</strong>",id:"determinism-property-b",level:3},{value:"<strong>Conclusion</strong>",id:"conclusion",level:2}],p={toc:u};function d(e){var t=e.components,a=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In the blockchain space, there's a pair of issues that everyone has to pick sides: upgradability vs determinism."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Upgradability")),(0,r.kt)("p",null,"Can I upgrade a smart contract after it's deployed on the blockchain? "),(0,r.kt)("p",null,"Suppose a smart contract gets widely adopted, then all of a sudden, someone notices a bug in the smart contract (sadly this will always happen in our industry). Can we upgrade the smart contract to the fixed state without any user interventions?"),(0,r.kt)("p",null,"Or, a different scenario: as technology advances, there might be new algorithms that make smart contracts run faster. Can we upgrade existing smart contracts with those benefits?"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Determinism")),(0,r.kt)("p",null,"This one has two aspects:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Determinism A: if I pick a smart contract to guard my tokens, will my tokens stay safe (could be unlocked by me and only by me) in the future?"),(0,r.kt)("li",{parentName:"ul"},"Determinism B: if I sign a transaction now, and send it later, will my transaction still be accepted by the blockchain?")),(0,r.kt)("p",null,"Note that a secure blockchain has more deterministic requirements than those mentioned here. I'm only including properties that relate to the discussed problem here."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Conflict")),(0,r.kt)("p",null,"If we think about it, we could find that there're always conflicts between upgradability and determinism:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"New behaviors introduced through the upgradability of a smart contract can potentially lead to unexpected ways to unlock a cell, or preventing the owners from unlocking themselves."),(0,r.kt)("li",{parentName:"ul"},"An already signed transaction might run into different behaviors through the upgradability of a smart contract, resulting it being rejected by the blockchain.")),(0,r.kt)("p",null,"At first, some blockchains opt for determinism. ",(0,r.kt)("a",{parentName:"p",href:"https://www.harvardmagazine.com/2000/01/code-is-law-html"},'The "code is law" idea')," thus became very famous in the blockchain space. But we all know that software design is all about tradeoffs. Given a certain situation, it makes sense to slightly sacrifice determinism, in exchange for the ease of upgradability. For example, when a vulnerability is discovered, everyone would expect their fund to be safe. Having upgradable contracts would equip developers the ability to deploy fixed contracts without any user intervention. Gradually, more blockchains have started to adopt the side of upgradability."),(0,r.kt)("p",null,'But the problem remains. Upgradable contracts break the "code is law" principle, meaning that a cell can be unlocked in unexpected ways that were not considered when it was created. So now the question is: can we ask for both in CKB?'),(0,r.kt)("p",null,"It turns out CKB does have support for both via a special contract. It grants the user a choice to choose between upgradability and determinism. One can use an upgradable contract that can be upgraded automatically for new features/fixes, while also locking their most precious tokens in a cell that only they themselves can unlock."),(0,r.kt)("p",null,"But to understand this very contract in CKB, we have to first take a look at some other ideas that support this behavior."),(0,r.kt)("h2",{id:"write-a-unique-type-script"},(0,r.kt)("strong",{parentName:"h2"},"Write A Unique Type Script")),(0,r.kt)("p",null,"Let's start with a different question: how do we create a cell with a unique ",(0,r.kt)("a",{parentName:"p",href:"https://docs.nervos.org/docs/basics/glossary#type-script"},"type script")," data structure in CKB? In other words, we want to make sure that once a cell is created, no other cells can be created with the same type script."),(0,r.kt)("p",null,"Note that this question might seem irrelevant to script upgradability right now, but please bear with me, we will see later how it will contribute to the final solution in CKB."),(0,r.kt)("p",null,"It turns out that a special smart contract referenced via the type script of a cell, can perfectly validate the above requirement. I strongly recommend that you can give it a try first, to see how you would design such a cell. This can be a very good thought exercise. When you are ready, here's the rough workflow for such a contract:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Abort with a failure if more than one input cell in this transaction uses the current type script;"),(0,r.kt)("li",{parentName:"ol"},"Abort with a failure if more than one output cell in this transaction uses the current type script;"),(0,r.kt)("li",{parentName:"ol"},"When no input cells use the current type script, read the following two pieces of information:\na. The OutPoint data structure from the first input cell in this transaction;\nb. The index of the first output cell using the current type script;"),(0,r.kt)("li",{parentName:"ol"},"Hash the two pieces of information gathered in 3 together, if the resulting hash matches ",(0,r.kt)("inlineCode",{parentName:"li"},"args")," part in current type script structure, return with success. Otherwise, abort with a failure.")),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/nervosnetwork/ckb-c-stdlib/blob/b51f9b1b6221398c76c6bb78d63a430d93e791bf/ckb_type_id.h"},"C implementation")," and a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/axonweb3/ckb-type-id/blob/bf59996428c75cb419bba0177de3e091b96fa64d/src/lib.rs"},"Rust")," one are both available for this workflow."),(0,r.kt)("p",null,"Attackers will be prevented from several different directions:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If an attacker tries to create a cell with the exactly same type script, there will be two cases:\na. A valid transaction will have different OutPoint data in the first input, or different output cell index from when we first created this cell;\nb. If the user tries to duplicate type script args as the first transaction input, CKB will signal a double-spent error;"),(0,r.kt)("li",{parentName:"ol"},"When the attacker tries to use a different type script args, it will be a different type script structure by definition.")),(0,r.kt)("p",null,"This way, we can ensure a cell will have unique type script across all live cells in CKB. Considering the fact that each type script structure can also be hashed, a cell in CKB can thus have a unique hash, or unique ID."),(0,r.kt)("h2",{id:"resolving-contracts-in-ckb-transaction"},(0,r.kt)("strong",{parentName:"h2"},"Resolving Contracts in CKB Transaction")),(0,r.kt)("p",null,"The above newly designed smart contract will act as the core for building upgradable smart contracts. What's still missing here, is a clever use of CKB's contract resolving process:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"CKB first extracts ",(0,r.kt)("inlineCode",{parentName:"li"},"code hash"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"hash type")," value from the lock/type script structure to run. To avoid ambiguity, we will denote ",(0,r.kt)("inlineCode",{parentName:"li"},"code hash")," gathered here as ",(0,r.kt)("inlineCode",{parentName:"li"},"running code hash"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"hash type")," as ",(0,r.kt)("inlineCode",{parentName:"li"},"running hash type"),"."),(0,r.kt)("li",{parentName:"ul"},"For each dep cell in the current transaction, a ",(0,r.kt)("inlineCode",{parentName:"li"},"test hash")," value will be calculated. Depending on the value of ",(0,r.kt)("inlineCode",{parentName:"li"},"running hash type"),", there will be different ways to calculate ",(0,r.kt)("inlineCode",{parentName:"li"},"test hash"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"running hash type")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"type"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"test hash")," will be the hash of type script data structure from the dep cell;"),(0,r.kt)("li",{parentName:"ul"},"Otherwise, ",(0,r.kt)("inlineCode",{parentName:"li"},"test hash")," will be the hash of cell data part from the dep cell;"))),(0,r.kt)("li",{parentName:"ul"},"CKB then looks for a dep cell whose ",(0,r.kt)("inlineCode",{parentName:"li"},"test hash")," matches ",(0,r.kt)("inlineCode",{parentName:"li"},"running code hash"),". In the absence of such a cell, CKB results in a validation error."),(0,r.kt)("li",{parentName:"ul"},"CKB uses the cell data from the located dep cell as the smart contract to run.")),(0,r.kt)("p",null,"Upgradability of smart contract has to do with ways to reference a changeable cell containing different smart contracts. In the upgrade process, the OutPoint structure for a cell will change (updating a cell is essentially destroying the old cell, then creating a new one), the cell data will also change (since we will need to store the fixed smart contract). Then what property can stay unchanged? In CKB's universe, lock and type script can definitely stay the same when updating a cell. Since lock script is typically used to represent ownership, we can perfectly use type script here to reference an upgradable smart contract."),(0,r.kt)("h2",{id:"putting-everything-together"},(0,r.kt)("strong",{parentName:"h2"},"Putting Everything Together")),(0,r.kt)("p",null,"There's still one problem unsolved, a potential attack remains. Consider this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A lock script L1 is stored in a cell C1 with type script T1;"),(0,r.kt)("li",{parentName:"ul"},"Alice guards her cells via a lock script L1 using ",(0,r.kt)("inlineCode",{parentName:"li"},"hash type")," as ",(0,r.kt)("inlineCode",{parentName:"li"},"type"),". By definition, she fills her script structure's ",(0,r.kt)("inlineCode",{parentName:"li"},"code hash")," field with the hash of type script T1;"),(0,r.kt)("li",{parentName:"ul"},"Bob creates a different cell C2 with the always-success lock script L2, and also use the same type script T1;"),(0,r.kt)("li",{parentName:"ul"},"Now Bob can use C2 as a dep cell to unlock Alice's cell. CKB won't be able to distinguish that Alice wants to use C1, while Bob provides C2. Both C1 and C2 use T1 as type script.")),(0,r.kt)("p",null,"That teaches us a very important lesson: if you build a lock/type script and want people to leverage the upgradability property, you have to make sure to use a cell with an unique and unforgeable type script in CKB universe."),(0,r.kt)("p",null,"Luckily, we just solved this problem! In the above we just developed a smart contract ensuring type script uniqueness in CKB universe. Putting together, upgradable smart contracts in CKB can be archived by combining the very smart contract developed above, with CKB's ability to resolve contracts via type scripts."),(0,r.kt)("h2",{id:"trust-issue"},(0,r.kt)("strong",{parentName:"h2"},"Trust Issue")),(0,r.kt)("p",null,"We do want to mention that this design is not without its drawbacks. You should really understand how it works and the tradeoffs involved before using it. This section tries to discuss some known considerations related to this feature."),(0,r.kt)("h3",{id:"determinism-property-a"},(0,r.kt)("strong",{parentName:"h3"},"Determinism Property A")),(0,r.kt)("p",null,"Type ID does provide a solution to challenges with regards to Determinism Property A: when a bug is discovered, it's possible to fix the smart contracts without affecting existing cells using the same smart contracts. But it does require certain considerations."),(0,r.kt)("h4",{id:"ownership"},(0,r.kt)("strong",{parentName:"h4"},"Ownership")),(0,r.kt)("p",null,"With a type ID solution, people might be able to steal your coin by hacking the cell containing smart contracts you use. Since typical cells are guarded by one or more signatures, some human errors could cause major problems. Fundamentally, it's a tradeoff situation:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},'For those truly paranoid, they might want to stick to the old way of referencing a script via its own hash, not the type script hash of the containing cell. The "code is law" principle is fully enforced here. You will know exactly what can be used to unlock your cell, and it won\'t change anytime in the future.'),(0,r.kt)("li",{parentName:"ol"},"For people willing to sacrifice a little bit, they can gain the ability to upgrade existing smart contracts for different benefits. But please do make sure to fully understand the lock script of the cell containing the script you use.")),(0,r.kt)("p",null,"For example, if you look at the deployed system scripts in CKB's mainnet, they all use type ID setup, but have all their lock scripts\u2019 code hash set to zeros, meaning that no one gets to change the lock script easily via a signature. We want to make sure that there's a need to change the default lock script, which will be realized via a fork agreed upon by the whole community. After all, IMHO, it really is the whole Nervos community that ",(0,r.kt)("em",{parentName:"p"},"owns")," CKB :P"),(0,r.kt)("p",null,"There are some initial ideas that you can use to guard the script contained in a cell. For example, in addition to type ID logic, the type script can also contains other logics to validate the actual script contained in its cell. For example, formal analysis methods might be used, or certain test cases can be provided in which the type script runs the actual script against. Only when the analysis or the test cases pass, will one be able to change script contained in a cell. Though I must say, these are just some preliminary ideas, much research and development work needs to be done to make this a reality."),(0,r.kt)("h4",{id:"availability"},(0,r.kt)("strong",{parentName:"h4"},"Availability")),(0,r.kt)("p",null,"A different issue with type ID, is the availability of the script. When you have a cell using a script with ",(0,r.kt)("inlineCode",{parentName:"p"},"hash type")," set as ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),", you are not worried someone might destroy the used script, you can always redeploy the script on-chain then unlock your cell."),(0,r.kt)("p",null,"But with a type ID solution, if something bad happens, and the cell with matching type script hash is destroyed, your cell will be locked forever, since you might never be able to build a cell with the same type script hash. There are some methods you can use, such as restricting the ability to destroy a cell with a type ID script, but they all just mitigate the problem, not completely solving it."),(0,r.kt)("h3",{id:"determinism-property-b"},(0,r.kt)("strong",{parentName:"h3"},"Determinism Property B")),(0,r.kt)("p",null,"We do want to mention that type ID does not provide a solution to property B. When you have a signed transaction, the behavior of this transaction won't be changed with the upgrade of one smart contract."),(0,r.kt)("p",null,"Though there is way that the type ID solution might affect an already signed transaction: If a transaction uses a script from a cell that gets updated, the cell referenced in the original OutPoint is already spent and the transaction will become invalid. But it could be argued that with the old referencing solution, this problem might also occur."),(0,r.kt)("h2",{id:"conclusion"},(0,r.kt)("strong",{parentName:"h2"},"Conclusion")),(0,r.kt)("p",null,"The above design of upgradable smart contracts has already seen wide usage in mainnet CKB now. Feel free to let us know your thoughts on this feature :)"))}d.isMDXComponent=!0}}]);