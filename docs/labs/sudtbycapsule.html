<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Write a SUDT script by Capsule · Nervos CKB Docs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Introduction"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Write a SUDT script by Capsule · Nervos CKB Docs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://docs.nervos.org/"/><meta property="og:description" content="## Introduction"/><meta property="og:image" content="https://docs.nervos.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://docs.nervos.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-139882771-1"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'UA-139882771-1');
            </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&amp;display=swap"/><script type="text/javascript" src="/js/extra.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo.png" alt="Nervos CKB Docs"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/basics/introduction" target="_self">Basics</a></li><li class="siteNavGroupActive"><a href="/docs/reference/introduction" target="_self">Reference</a></li><li class="siteNavGroupActive"><a href="/docs/labs/introduction" target="_self">Labs</a></li><li class="siteNavGroupActive"><a href="/docs/integrate/introduction" target="_self">Integrate</a></li><li class="siteNavGroupActive"><a href="/docs/essays/introduction" target="_self">Essays</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Labs</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Basics<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/basics/introduction">Basics Introduction</a></li><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Concepts</h4><ul><li class="navListItem"><a class="navItem" href="/docs/basics/concepts/nervos-blockchain">Nervos Blockchain</a></li><li class="navListItem"><a class="navItem" href="/docs/basics/concepts/cell-model">Cell Model</a></li><li class="navListItem"><a class="navItem" href="/docs/basics/concepts/consensus">Consensus</a></li><li class="navListItem"><a class="navItem" href="/docs/basics/concepts/economics">Economics</a></li><li class="navListItem"><a class="navItem" href="/docs/basics/concepts/ckb-vm">CKB-VM</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Guides</h4><ul><li class="navListItem"><a class="navItem" href="/docs/basics/guides/devchain">Run a CKB Dev Blockchain</a></li><li class="navListItem"><a class="navItem" href="/docs/basics/guides/mainnet">Run a CKB Mainnet Node</a></li><li class="navListItem"><a class="navItem" href="/docs/basics/guides/testnet">Run a CKB Testnet Node</a></li><li class="navListItem"><a class="navItem" href="/docs/basics/guides/neuron">Neuron Wallet Guide</a></li></ul></div><li class="navListItem"><a class="navItem" href="/docs/basics/tools">Tools</a></li><li class="navListItem"><a class="navItem" href="/docs/basics/glossary">Glossary</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Reference<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/reference/introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/reference/cell">Cell</a></li><li class="navListItem"><a class="navItem" href="/docs/reference/script">Script</a></li><li class="navListItem"><a class="navItem" href="/docs/reference/transaction">Transaction</a></li><li class="navListItem"><a class="navItem" href="/docs/reference/rpc">JSON-RPC</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Labs<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/labs/introduction">Introduction</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/labs/sudtbycapsule">Write a SUDT script by Capsule</a></li><li class="navListItem"><a class="navItem" href="/docs/labs/lumos-nervosdao">Introduction to Lumos via NervosDAO</a></li><li class="navListItem"><a class="navItem" href="/docs/labs/capsule-dynamic-loading-tutorial">Dynamic loading in Capsule</a></li><li class="navListItem"><a class="navItem" href="/docs/labs/polyjuice">Technical Bits on Polyjuice</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Integrate<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/integrate/introduction">Q&amp;A | For Wallets/Exchanges/Mining Pools</a></li><li class="navListItem"><a class="navItem" href="/docs/integrate/sdk">Nervos CKB SDK</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Essays<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/essays/introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/essays/rfcs">A Tour of RFCs</a></li><li class="navListItem"><a class="navItem" href="/docs/essays/lifecycle">Transaction validation lifecycle</a></li><li class="navListItem"><a class="navItem" href="/docs/essays/debug">Tips for debugging CKB script</a></li><li class="navListItem"><a class="navItem" href="/docs/essays/rules">The General Workflow for Constructing a Transaction</a></li><li class="navListItem"><a class="navItem" href="/docs/essays/dependencies">Script dependencies</a></li><li class="navListItem"><a class="navItem" href="/docs/essays/introduction-to-ckb-studio">Introduction to CKB Studio</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Write a SUDT script by Capsule</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="introduction"></a><a href="#introduction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction</h2>
<p><a href="https://github.com/nervosnetwork/capsule">Capsule</a> is a set of tools for Rust developers to develop scripts on CKB which covers the entire lifecycle of script development: writing,debugging,testing and deployment. We aim to improve the development experience of Rust developers.</p>
<p>In this tutorial, you will learn how to write a SUDT script using Capsule. SUDT is the abbreviation of Simple User Defined Token which defines a minimal standard that contains what’s absolutely needed for dapp developers to issue custom tokens on Nervos CKB. You can refer to <a href="https://talk.nervos.org/t/rfc-simple-udt-draft-spec/4333">RFC: Simple UDT Draft Spec</a> for more details.</p>
<p>We expect that:</p>
<ul>
<li>You are Rust developers and generally familiar with software development, writing code, and running your code.</li>
<li>You are generally familiar with Nervos CKB and have completed the  <a href="/docs/basics/guides/devchain">How to use a development blockchain</a></li>
<li>You are open to learning about the bleeding edge of blockchain development</li>
</ul>
<p>If you run into an issue on this tutorial you can <a href="https://github.com/nervosnetwork/capsule">create a new issue</a> or contact us on <a href="https://talk.nervos.org/">Nervos talk</a> or <a href="https://discord.gg/n6tx7uC">Discord</a>.</p>
<p>What you will be doing:</p>
<ul>
<li>Prepare to write the SUDT script</li>
<li>Write a SUDT script</li>
<li>Testing</li>
<li>Deployment</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="prepare-to-write-the-sudt-script"></a><a href="#prepare-to-write-the-sudt-script" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prepare to write the SUDT script</h2>
<h3><a class="anchor" aria-hidden="true" id="run-a-dev-chain-and-ckb-cli"></a><a href="#run-a-dev-chain-and-ckb-cli" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Run a dev chain and ckb-cli</h3>
<p>You should be able to run a dev chain and know about how to use <code>ckb-cli</code> to send transactions.  If you do not, please refer to this tutorial：<a href="/docs/basics/guides/devchain">How to use a development blockchain</a>.  Please don't forget to add <code>ckb-cli</code> to the  PATH environment variable</p>
<h3><a class="anchor" aria-hidden="true" id="install-capsule"></a><a href="#install-capsule" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Install capsule</h3>
<p>To use capsule, you need <code>docker</code>. It is recommended to install the latest version:</p>
<ul>
<li><a href="https://docs.docker.com/get-docker/">Install docker</a></li>
</ul>
<p>Note: The current user must have permission to manage Docker instances. (How to manage Docker as a non-root user)[<a href="https://docs.docker.com/engine/install/linux-postinstall/">https://docs.docker.com/engine/install/linux-postinstall/</a>].</p>
<p>Now you can proceed to install capsule, It is recommended to <a href="https://github.com/nervosnetwork/capsule/releases/tag/v0.1.3">download the binary</a></p>
<p>Or you can install from source:</p>
<pre><code class="hljs">cargo install capsule --git https://github.com/nervosnetwork/capsule.git --<span class="hljs-keyword">tag</span> <span class="hljs-title">v0</span>.<span class="hljs-number">1.3</span>
</code></pre>
<p>Then check if it works with:</p>
<pre><code class="hljs">capsule<span class="hljs-built_in"> check
</span></code></pre>
<p><details>
<summary>(click here to view response)</summary></p>
<pre><code class="hljs css language-bash">------------------------------
docker    installed
ckb-cli    installed
------------------------------
</code></pre>
<p></details></p>
<h3><a class="anchor" aria-hidden="true" id="create-a-project"></a><a href="#create-a-project" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Create a project</h3>
<pre><code class="hljs">capsule <span class="hljs-keyword">new</span> <span class="hljs-type">my</span>-sudt
</code></pre>
<p><details>
<summary>(click here to view response)</summary></p>
<pre><code class="hljs css language-bash">New project <span class="hljs-string">"my-sudt"</span>
Created file <span class="hljs-string">"capsule.toml"</span>
Created file <span class="hljs-string">"deployment.toml"</span>
Created file <span class="hljs-string">"README.md"</span>
Created file <span class="hljs-string">"Cargo.toml"</span>
Created <span class="hljs-string">"/PATH/my-sudt"</span>
     Created binary (application) `my-sudt` package
Created contract <span class="hljs-string">"my-sudt"</span>
Created tests
     Created binary (application) `tests` package
Done
</code></pre>
<p></details></p>
<p>You can check the project’s layout：</p>
<pre><code class="hljs">ls <span class="hljs-keyword">my</span>-sudt
</code></pre>
<p><details>
<summary>(click here to view response)</summary></p>
<pre><code class="hljs css language-bash">
build  capsule.toml  Cargo.toml  contracts  deployment.toml  migrations  README.md  tests
</code></pre>
<p></details></p>
<p>The default contract is under <code>my-sudt/contracts/my-sudt</code> directory which is a normal cargo project:</p>
<pre><code class="hljs">ls <span class="hljs-keyword">my</span>-sudt/contracts/<span class="hljs-keyword">my</span>-sudt
</code></pre>
<p><details>
<summary>(click here to view response)</summary></p>
<pre><code class="hljs css language-bash">
Cargo.toml  src
</code></pre>
<p></details></p>
<p>You can open <code>my-sudt/contracts/my-sudt/src/main.rs</code> to see some pre-generated code:</p>
<pre><code class="hljs css language-rust"><span class="hljs-meta">#![no_std]</span>
<span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![feature(lang_items)]</span>
<span class="hljs-meta">#![feature(alloc_error_handler)]</span>
<span class="hljs-meta">#![feature(panic_info_message)]</span>

<span class="hljs-comment">// Import from `core` instead of from `std` since we are in no-std mode</span>
<span class="hljs-keyword">use</span> core::result::<span class="hljs-built_in">Result</span>;

<span class="hljs-comment">// Import heap related library from `alloc`</span>
<span class="hljs-comment">// https://doc.rust-lang.org/alloc/index.html</span>
<span class="hljs-keyword">use</span> alloc::{vec, vec::<span class="hljs-built_in">Vec</span>};

<span class="hljs-comment">// Import CKB syscalls and structures</span>
<span class="hljs-comment">// https://nervosnetwork.github.io/ckb-std/riscv64imac-unknown-none-elf/doc/ckb_std/index.html</span>
<span class="hljs-keyword">use</span> ckb_std::{
    entry,
    default_alloc,
    debug,
    high_level::{load_script, load_tx_hash},
    error::SysError,
    ckb_types::{bytes::Bytes, prelude::*},
};

entry!(entry);
default_alloc!();

<span class="hljs-comment">/// Program entry</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">entry</span></span>() -&gt; <span class="hljs-built_in">i8</span> {
    <span class="hljs-comment">// Call main function and return error code</span>
    <span class="hljs-keyword">match</span> main() {
        <span class="hljs-literal">Ok</span>(_) =&gt; <span class="hljs-number">0</span>,
        <span class="hljs-literal">Err</span>(err) =&gt; err <span class="hljs-keyword">as</span> <span class="hljs-built_in">i8</span>,
    }
}

<span class="hljs-comment">/// Error</span>
<span class="hljs-meta">#[repr(i8)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Error</span></span> {
    IndexOutOfBound = <span class="hljs-number">1</span>,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    <span class="hljs-comment">// Add customized errors here...</span>
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">From</span>&lt;SysError&gt; <span class="hljs-keyword">for</span> Error {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">from</span></span>(err: SysError) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">use</span> SysError::*;
        <span class="hljs-keyword">match</span> err {
            IndexOutOfBound =&gt; Self::IndexOutOfBound,
            ItemMissing =&gt; Self::ItemMissing,
            LengthNotEnough(_) =&gt; Self::LengthNotEnough,
            Encoding =&gt; Self::Encoding,
            Unknown(err_code) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"unexpected sys error {}"</span>, err_code),
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt; {
    <span class="hljs-comment">// remove below examples and write your code here</span>

    <span class="hljs-keyword">let</span> script = load_script()?;
    <span class="hljs-keyword">let</span> args: Bytes = script.args().unpack();
    debug!(<span class="hljs-string">"script args is {:?}"</span>, args);

    <span class="hljs-keyword">let</span> tx_hash = load_tx_hash()?;
    debug!(<span class="hljs-string">"tx hash is {:?}"</span>, tx_hash);

    <span class="hljs-keyword">let</span> _buf: <span class="hljs-built_in">Vec</span>&lt;_&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0u8</span>; <span class="hljs-number">32</span>];

    <span class="hljs-literal">Ok</span>(())
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="build-the-project"></a><a href="#build-the-project" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Build the project</h3>
<p>Enter into the project  <code>my-sudt</code> and build it.</p>
<pre><code class="hljs"><span class="hljs-attr">cd</span> <span class="hljs-string">my-sudt</span>
<span class="hljs-attr">capsule</span> <span class="hljs-string">build</span>
</code></pre>
<p><details>
<summary>(click here to view response)</summary></p>
<pre><code class="hljs css language-bash">
Building contract my-sudt
    Updating crates.io index
   Compiling cc v1.0.56
   Compiling cfg-if v0.1.10
   Compiling buddy-alloc v0.3.0
   Compiling molecule v0.6.0
   Compiling ckb-allocator v0.1.1
   Compiling ckb-standalone-types v0.0.1-pre.1
   Compiling ckb-std v0.4.1
   Compiling my-sudt v0.1.0 (/code/contracts/my-sudt)
    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 8.73s
Done
</code></pre>
<p></details></p>
<p>You will find a new generated contract binary in the <code>build/debug</code> directory:</p>
<pre><code class="hljs">ls build/<span class="hljs-builtin-name">debug</span>
</code></pre>
<p><details>
<summary>(click here to view response)</summary></p>
<pre><code class="hljs css language-bash">
my-sudt
</code></pre>
<p></details></p>
<p>You're all done? Great, let's get coding.</p>
<h2><a class="anchor" aria-hidden="true" id="write-a-sudt-script"></a><a href="#write-a-sudt-script" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Write a SUDT script</h2>
<p>SUDT scripts can be in <strong>owner mode</strong> and <strong>normal mode</strong> which include different verification rules, we should deal with that when we're coding.</p>
<ul>
<li><strong>owner mode</strong>：If one of the transaction input has a lock script matching the SUDT script argument, the SUDT script will be in owner mode. We don’t need to perform checks, the owner can perform any operations such as issuing more SUDTs or burning SUDTs.</li>
<li><strong>normal mode：</strong>Otherwise, the SUDT script will be in normal mode. We need to ensure the sum of all inputs’ capacity is not smaller than the sum of all outputs capacity. Please note that only one type of SUDT can be issued for each unique lock script.</li>
</ul>
<p>The script is consisted of four parts：load script、check inputs、load inputs / outputs UDT amount、error handling. We should check the used libraries before coding.</p>
<h3><a class="anchor" aria-hidden="true" id="check-the-used-libraries"></a><a href="#check-the-used-libraries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Check the used libraries</h3>
<p>Open <code>contracts/my-sudt/Cargo.toml</code>, we already have a dependency:</p>
<pre><code class="hljs"><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">ckb-std</span> = <span class="hljs-string">"0.4.1"</span>
</code></pre>
<ul>
<li><code>ckb-std</code> is a crate used to handling CKB syscalls.</li>
<li><code>ckb-standalone-types</code> is a crate which re-exported as the <code>ckb_std::ckb_types</code> provides the definition of CKB structures.</li>
</ul>
<p>You may refer to <a href="https://github.com/nervosnetwork/capsule/wiki/Rust-libraries">Rust libraries</a> for more useful crates. We can only use crates which supports <code>no-std</code> in scripts.</p>
<h3><a class="anchor" aria-hidden="true" id="load-script"></a><a href="#load-script" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Load Script</h3>
<p>At the beginning of the script, we need to check the SUDT’s mode, if it is owner mode, we simply skip the verification code and return <code>0</code>, which represents the verification is successful, otherwise we check the amount of UDT.</p>
<p>To achieve this, we need to load <code>args</code> of the current script, which the generated code already did for us. So we just remove the unused lines from the <code>main</code> function.</p>
<p>In the code below, we load the current script(SUDT)'s args field, and invoke <code>check_owner_mode</code> which we have not defined yet.</p>
<p>Notice since we are using no-std Rust, we can't directly use the <code>std</code> in the code. Instead, we need to import the <code>Vec</code> struct from the <a href="https://doc.rust-lang.org/stable/alloc/index.html">alloc</a> crate, which is a rust builtin crate contains heap related structs.</p>
<pre><code class="hljs css language-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt; {
    <span class="hljs-comment">// load current script</span>
    <span class="hljs-comment">// check verification branch is owner mode or normal mode</span>
    <span class="hljs-keyword">let</span> script = load_script()?;
    <span class="hljs-keyword">let</span> args: Bytes = script.args().unpack();

    <span class="hljs-comment">// unpack the Script#args field</span>
    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = script.args().unpack();

    <span class="hljs-comment">// return success if owner mode is true</span>
    <span class="hljs-keyword">if</span> check_owner_mode(&amp;args)? {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(());
    }

    <span class="hljs-comment">// more verifications ...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(());
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="check-inputs"></a><a href="#check-inputs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Check inputs</h3>
<p>Now we should  check the owner mode status by defining the <code>check_owner_mode</code> function：</p>
<p>We need to load every input's lock hash and compare it to the script's args. If we find an input's lock hash corresponds to the script's args, we are in owner mode; otherwise, we iterate all the inputs and finally got an <code>IndexOutOfBound</code> error, which means we are in normal mode.</p>
<p>We use <a href="https://nervosnetwork.github.io/ckb-std/riscv64imac-unknown-none-elf/doc/ckb_std/high_level/fn.load_cell_lock_hash.html">load_cell_lock_hash</a> to load cell's lock hash from CKB. The <code>Source::Input</code> and <code>i</code> args denote we load <code>input</code> from <code>i-th</code> inputs.</p>
<p>The error <code>SysError::IndexOutOfBound</code> represents that we request an index that does not exist, which means we cannot find a matched input cell, so we return <code>Ok(false)</code>.</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">use</span> ckb_std::{
    high_level::{load_cell_lock_hash},
    ckb_constants::Source,
};

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">check_owner_mode</span></span>(args: &amp;Bytes) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">bool</span>, Error&gt; {
    <span class="hljs-comment">// With owner lock script extracted, we will look through each input in the</span>
    <span class="hljs-comment">// current transaction to see if any unlocked cell uses owner lock.</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.. {
        <span class="hljs-comment">// check input's lock_hash with script args</span>
        <span class="hljs-keyword">let</span> lock_hash = <span class="hljs-keyword">match</span> load_cell_lock_hash(
            i,
            Source::Input,
        ) {
            <span class="hljs-literal">Ok</span>(lock_hash) =&gt; lock_hash,
            <span class="hljs-literal">Err</span>(SysError::IndexOutOfBound) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(<span class="hljs-literal">false</span>),
            <span class="hljs-literal">Err</span>(err) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(err.into()),
        };
        <span class="hljs-comment">// invalid length of loaded data</span>
        <span class="hljs-keyword">if</span> args[..] == lock_hash[..] {
           <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(<span class="hljs-literal">true</span>);
        }
    }
    <span class="hljs-literal">Ok</span>(<span class="hljs-literal">false</span>)
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="load-inputs--outputs-udt-amount"></a><a href="#load-inputs--outputs-udt-amount" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Load inputs / outputs UDT amount</h3>
<p>If the owner mode is <code>false</code>, we should continue the verification: check the total input SUDT amount is greater than or equals to the total output SUDT amount.</p>
<ul>
<li><p>Define two methods:</p>
<ul>
<li><code>collect_inputs_amount</code> ：collect total input SUDT amount</li>
<li><code>collect_outputs_amount</code> ：collect total output SUDT amount.</li>
</ul></li>
<li><p>Since we aim to read all SUDT inputs which type is the current script(SUDT), we  can use <code>Source::GroupInput</code> instead of  <code>Source::Input</code>.</p></li>
<li><p><code>Source::GroupInput</code> and <code>i</code>   means load the <code>i-th</code> input from the &quot;input group&quot;.</p></li>
</ul>
<p>Tips：</p>
<ul>
<li>By using <code>Source::GroupInput</code>  in the syscall, CKB verification engine will automatically group the inputs/outputs by <code>lock</code> and <code>type</code> script.</li>
<li>The data type of SUDT is  <code>u128</code>, which is 16 bytes so we use the 16 bytes buffer.</li>
<li><code>i-th</code> input of <code>Source::Input</code>(index of all inputs) may be or may not be the same cell of the <code>i-th</code> input of <code>Source::GroupInput</code> (index of inputs which lock/type is the current script).</li>
</ul>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">const</span> UDT_LEN: <span class="hljs-built_in">usize</span> = <span class="hljs-number">16</span>;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">collect_inputs_amount</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">u128</span>, Error&gt; {
    <span class="hljs-comment">// let's loop through all input cells containing current UDTs,</span>
    <span class="hljs-comment">// and gather the sum of all input tokens.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> inputs_amount: <span class="hljs-built_in">u128</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buf = [<span class="hljs-number">0u8</span>; UDT_LEN];

    <span class="hljs-comment">// u128 is 16 bytes</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.. {
        <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">match</span> load_cell_data(i, Source::GroupInput) {
            <span class="hljs-literal">Ok</span>(data) =&gt; data,
            <span class="hljs-literal">Err</span>(SysError::IndexOutOfBound) =&gt; <span class="hljs-keyword">break</span>,
            <span class="hljs-literal">Err</span>(err) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(err.into()),
        };

        <span class="hljs-keyword">if</span> data.len() != UDT_LEN {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::Encoding);
        }
        buf.copy_from_slice(&amp;data);
        inputs_amount += <span class="hljs-built_in">u128</span>::from_le_bytes(buf);
    }
    <span class="hljs-literal">Ok</span>(inputs_amount)
}
</code></pre>
<p>The <code>collect_outputs_amount</code> function is similar, except we load data from outputs:</p>
<pre><code class="hljs css language-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">collect_outputs_amount</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">u128</span>, Error&gt; {
    <span class="hljs-comment">// With the sum of all input UDT tokens gathered, let's now iterate through</span>
    <span class="hljs-comment">// output cells to grab the sum of all output UDT tokens.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> outputs_amount: <span class="hljs-built_in">u128</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> i = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// u128 is 16 bytes</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buf = [<span class="hljs-number">0u8</span>; UDT_LEN];
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.. {
        <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">match</span> load_cell_data(i, Source::GroupOutput) {
            <span class="hljs-literal">Ok</span>(data) =&gt; data,
            <span class="hljs-literal">Err</span>(SysError::IndexOutOfBound) =&gt; <span class="hljs-keyword">break</span>,
            <span class="hljs-literal">Err</span>(err) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(err.into()),
        };

        <span class="hljs-keyword">if</span> data.len() != UDT_LEN {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::Encoding);
        }
        buf.copy_from_slice(&amp;data);
        outputs_amount += <span class="hljs-built_in">u128</span>::from_le_bytes(buf);
    }
    <span class="hljs-literal">Ok</span>(outputs_amount)
}
</code></pre>
<ul>
<li>Update the <code>main</code> function to check inputs / outputs UDT amount:</li>
</ul>
<pre><code class="hljs css language-rust"><span class="hljs-comment">/// Error</span>
<span class="hljs-meta">#[repr(i8)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Error</span></span> {
    IndexOutOfBound = <span class="hljs-number">1</span>,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    Amount
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;(), Error&gt; {
    <span class="hljs-keyword">let</span> script = load_script()?;
    <span class="hljs-keyword">let</span> args: Bytes = script.args().unpack();

    <span class="hljs-comment">// return success if owner mode is true</span>
    <span class="hljs-keyword">if</span> check_owner_mode(&amp;args)? {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(());
    }

    <span class="hljs-keyword">let</span> inputs_amount = collect_inputs_amount()?;
    <span class="hljs-keyword">let</span> outputs_amount = collect_outputs_amount()?;

    <span class="hljs-keyword">if</span> inputs_amount &lt; outputs_amount {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(Error::Amount);
    }

    <span class="hljs-literal">Ok</span>(())
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="use-iterator-to-query-cells"></a><a href="#use-iterator-to-query-cells" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use Iterator to query cells</h3>
<p>In the previous code, we use <code>for</code> loop to iterate inputs and outputs, since iteration over cells is a common pattern in CKB programming, <code>ckb-std</code> provides a high-level interface <a href="https://nervosnetwork.github.io/ckb-std/riscv64imac-unknown-none-elf/doc/ckb_std/high_level/struct.QueryIter.html">QueryIter</a> to handle it.</p>
<p>QueryIter needs two args, the first is a loading function, the seconds is <code>Source</code>. This is an example to load all grouped inputs cells data <code>QueryIter::new(load_cell_data, Source::GroupInput)</code>.</p>
<p>Rewrite our functions:</p>
<pre><code class="hljs css language-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">check_owner_mode</span></span>(args: &amp;Bytes) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">bool</span>, Error&gt; {
    <span class="hljs-comment">// With owner lock script extracted, we will look through each input in the</span>
    <span class="hljs-comment">// current transaction to see if any unlocked cell uses owner lock.</span>
    <span class="hljs-keyword">let</span> is_owner_mode = QueryIter::new(load_cell_lock_hash, Source::Input)
        .find(|lock_hash| args[..] == lock_hash[..]).is_some();
    <span class="hljs-literal">Ok</span>(is_owner_mode)
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">collect_inputs_amount</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">u128</span>, Error&gt; {
    <span class="hljs-comment">// let's loop through all input cells containing current UDTs,</span>
    <span class="hljs-comment">// and gather the sum of all input tokens.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buf = [<span class="hljs-number">0u8</span>; UDT_LEN];

    <span class="hljs-keyword">let</span> udt_list = QueryIter::new(load_cell_data, Source::GroupInput)
        .map(|data|{
            <span class="hljs-keyword">if</span> data.len() == UDT_LEN {
                buf.copy_from_slice(&amp;data);
                <span class="hljs-comment">// u128 is 16 bytes</span>
                <span class="hljs-literal">Ok</span>(<span class="hljs-built_in">u128</span>::from_le_bytes(buf))
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-literal">Err</span>(Error::Encoding)
            }
        }).collect::&lt;<span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;, Error&gt;&gt;()?;
    <span class="hljs-literal">Ok</span>(udt_list.into_iter().sum::&lt;<span class="hljs-built_in">u128</span>&gt;())
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">collect_outputs_amount</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">u128</span>, Error&gt; {
    <span class="hljs-comment">// With the sum of all input UDT tokens gathered, let's now iterate through</span>
    <span class="hljs-comment">// output cells to grab the sum of all output UDT tokens.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buf = [<span class="hljs-number">0u8</span>; UDT_LEN];

    <span class="hljs-keyword">let</span> udt_list = QueryIter::new(load_cell_data, Source::GroupOutput)
        .map(|data|{
            <span class="hljs-keyword">if</span> data.len() == UDT_LEN {
                buf.copy_from_slice(&amp;data);
                <span class="hljs-comment">// u128 is 16 bytes</span>
                <span class="hljs-literal">Ok</span>(<span class="hljs-built_in">u128</span>::from_le_bytes(buf))
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-literal">Err</span>(Error::Encoding)
            }
        }).collect::&lt;<span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">Vec</span>&lt;_&gt;, Error&gt;&gt;()?;
    <span class="hljs-literal">Ok</span>(udt_list.into_iter().sum::&lt;<span class="hljs-built_in">u128</span>&gt;())
}

</code></pre>
<p>Now we have finished the SUDT script, you may refer to <a href="https://github.com/jjyr/my-sudt/blob/master/contracts/my-sudt/src/main.rs">Full code of my-sudt</a> to check the full script code. If you are interested, you may also check <a href="https://github.com/nervosnetwork/ckb-miscellaneous-scripts/blob/master/c/simple_udt.c">the SUDT script written in C</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="build-the-project-1"></a><a href="#build-the-project-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Build the project</h3>
<p>Run <code>capsule build</code> under the project directory to build the script.If no error occurred, we can find the script binary at <code>my-usdt/build/debug/my-sudt</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="testing"></a><a href="#testing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Testing</h2>
<p>We will use the <code>ckb-testtool</code> crate to construct transactions and context for our testing.</p>
<h3><a class="anchor" aria-hidden="true" id="check-the-default-tests"></a><a href="#check-the-default-tests" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Check the default tests</h3>
<p>When create the project <code>my-sudt</code>,<code>capsule</code>  have generated the default tests.The default tests create mock cells and unlock them for testing.</p>
<p>Use  <code>capsule build</code> under the project directory to build the script,
then use <code>capsule test</code> to run the default tests.We will find the error message:</p>
<pre><code class="hljs">failures:

---- tests<span class="hljs-type">::test_basic</span> stdout ----
<span class="hljs-keyword">thread</span> <span class="hljs-string">'tests::test_basic'</span> panicked at <span class="hljs-string">'pass verification: Error { kind: ValidationFailure(4)Script }'</span>, tests/src/tests.rs:<span class="hljs-number">52</span>:<span class="hljs-number">5</span>
note: run <span class="hljs-keyword">with</span> <span class="hljs-string">`RUST_BACKTRACE=1`</span> environment <span class="hljs-built_in">variable</span> <span class="hljs-keyword">to</span> display a backtrace


failures:
    tests<span class="hljs-type">::test_basic</span>
</code></pre>
<p>The error number <code>4</code> in <code>Error { kind: ValidationFailure(4)</code>  refers to <code>Error::Encoding</code>, which means the cell’s data type is not <code>u128</code>.</p>
<p>Let’s check the default tests code  <code>tests/src/tests.rs</code>  to find out how to write the tests, then we can write new tests adapted <code>my-sudt</code>：</p>
<ul>
<li>In the beginning part, initialize the  <code>Context</code> which is a structure to simulate the chain environment. We can use <code>Context</code> to deploy exists cells and mock block headers.<code>deploy_contract</code> will return the  <code>out_point</code> of the script.</li>
</ul>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// deploy contract</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> context = Context::default();
    <span class="hljs-keyword">let</span> contract_bin: Bytes = Loader::default().load_binary(<span class="hljs-string">"my-sudt"</span>);
    <span class="hljs-keyword">let</span> contract_out_point = context.deploy_contract(contract_bin);
</code></pre>
<ul>
<li>Then <code>build_script</code> is called with the script's <code>out_point</code> , this function returns the <code>Script</code> which uses our script as the code. <code>create_cell</code> creates an existing cell in the context, which uses our script as the <code>lock_script</code>.</li>
</ul>
<p><em>Please note the default tests assume the script is a lock_script, but in our case, <code>my-sudt</code> is a type_script. We'll fix it later.</em></p>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// prepare scripts</span>
    <span class="hljs-keyword">let</span> lock_script = context.build_script(&amp;contract_out_point, <span class="hljs-built_in">Default</span>::default()).expect(<span class="hljs-string">"script"</span>);
    <span class="hljs-keyword">let</span> lock_script_dep = CellDep::new_builder().out_point(contract_out_point).build();

    <span class="hljs-comment">// prepare cells</span>
    <span class="hljs-keyword">let</span> input_out_point = context.create_cell(
        CellOutput::new_builder()
            .capacity(<span class="hljs-number">1000u64</span>.pack())
            .lock(lock_script.clone())
            .build(),
        Bytes::new(),
    );
    <span class="hljs-keyword">let</span> input = CellInput::new_builder()
        .previous_output(input_out_point)
        .build();
</code></pre>
<ul>
<li>After that, build two outputs cells and a transaction structure.It is necessary to include  <code>cell_deps</code> field in the transaction which should contain all the referenced scripts, in this case, we can only refer to <code>my-sudt</code>.  <code>complete_tx</code>  also implement <code>cell_deps</code>, while the field is already completed manually, this line is not necessary.</li>
</ul>
<p>Please note that the  transaction's <code>outputs_data</code> must have the same length with the <code>outputs</code>, even the data is empty.</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">let</span> outputs = <span class="hljs-built_in">vec!</span>[
        CellOutput::new_builder()
            .capacity(<span class="hljs-number">500u64</span>.pack())
            .lock(lock_script.clone())
            .build(),
        CellOutput::new_builder()
            .capacity(<span class="hljs-number">500u64</span>.pack())
            .lock(lock_script)
            .build(),
    ];

    <span class="hljs-keyword">let</span> outputs_data = <span class="hljs-built_in">vec!</span>[Bytes::new(); <span class="hljs-number">2</span>];

    <span class="hljs-comment">// build transaction</span>
    <span class="hljs-keyword">let</span> tx = TransactionBuilder::default()
        .input(input)
        .outputs(outputs)
        .outputs_data(outputs_data.pack())
        .cell_dep(lock_script_dep)
        .build();
    <span class="hljs-keyword">let</span> tx = context.complete_tx(tx);
</code></pre>
<ul>
<li>Finally, verify the transaction:</li>
</ul>
<pre><code class="hljs"><span class="hljs-comment">// run</span>
    <span class="hljs-selector-tag">context</span>
        <span class="hljs-selector-class">.verify_tx</span>(&amp;tx, MAX_CYCLES)
        <span class="hljs-selector-class">.expect</span>(<span class="hljs-string">"pass verification"</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="write-new-tests"></a><a href="#write-new-tests" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Write new tests</h3>
<p>We should create mock SUDT cells and spend them for testing SUDT verification.
As <code>my-sudt</code> script is a <code>type_script</code> we need another script as <code>lock_script</code> for mock cells, it is recommended to use <code>always success</code> script returned <code>0</code>. <code>always success</code> is built-in in the <code>ckb-testtool</code>.</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">use</span> ckb_testtool::{builtin::ALWAYS_SUCCESS, context::Context};

    <span class="hljs-comment">// deploy always_success script</span>
    <span class="hljs-keyword">let</span> always_success_out_point = context.deploy_contract(ALWAYS_SUCCESS.clone());
</code></pre>
<p>Before writing the code, let's think about our  test cases:</p>
<ol>
<li>Return success when inputs capacity equals to outputs capacity.</li>
<li>Return success when inputs capacity is greater than outputs capacity.</li>
<li>Return failure when inputs capacity is less than outputs capacity.</li>
<li>Return success when inputs capacity is less than outputs token with <code>owner mode</code> activated.</li>
</ol>
<ul>
<li><p>Define <code>build_test_context</code> to build transactions. There are three args:</p>
<ul>
<li>The data type of  <code>inputs_token</code> and <code>outputs_token</code>  is  <code>u128</code>. The function can generate SUDT inputs cells and outputs cells according to the two args.</li>
<li><code>is_owner_mode</code> refers to the current transaction is in SUDT owner mode or normal mode.</li>
</ul></li>
<li><p>Deploy the SUDT and <code>always-success</code> scripts.</p></li>
</ul>
<p>Please note that if <code>is_owner_mode</code> is true, we will set <code>lock_script</code>'s <code>lock_hash</code> as <code>owner script hash</code>; otherwise, we will set <code>[0u8; 32]</code> which implies can't enter into owner mode.</p>
<pre><code class="hljs css language-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">build_test_context</span></span>(
    inputs_token: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u128</span>&gt;,
    outputs_token: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u128</span>&gt;,
    is_owner_mode: <span class="hljs-built_in">bool</span>,
) -&gt; (Context, TransactionView) {
    <span class="hljs-comment">// deploy my-sudt script</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> context = Context::default();
    <span class="hljs-keyword">let</span> sudt_bin: Bytes = Loader::default().load_binary(<span class="hljs-string">"my-sudt"</span>);
    <span class="hljs-keyword">let</span> sudt_out_point = context.deploy_contract(sudt_bin);
    <span class="hljs-comment">// deploy always_success script</span>
    <span class="hljs-keyword">let</span> always_success_out_point = context.deploy_contract(ALWAYS_SUCCESS.clone());

    <span class="hljs-comment">// build lock script</span>
    <span class="hljs-keyword">let</span> lock_script = context
        .build_script(&amp;always_success_out_point, <span class="hljs-built_in">Default</span>::default())
        .expect(<span class="hljs-string">"script"</span>);
    <span class="hljs-keyword">let</span> lock_script_dep = CellDep::new_builder()
        .out_point(always_success_out_point)
        .build();

    <span class="hljs-comment">// build sudt script</span>
    <span class="hljs-keyword">let</span> sudt_script_args: Bytes = <span class="hljs-keyword">if</span> is_owner_mode {
        <span class="hljs-comment">// use always_success script hash as owner's lock</span>
        <span class="hljs-keyword">let</span> lock_hash: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">32</span>] = lock_script.calc_script_hash().unpack();
        lock_hash.to_vec().into()
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// use zero hash as owner's lock which implies we can never enter owner mode</span>
        [<span class="hljs-number">0u8</span>; <span class="hljs-number">32</span>].to_vec().into()
    };

    <span class="hljs-keyword">let</span> sudt_script = context
        .build_script(&amp;sudt_out_point, sudt_script_args)
        .expect(<span class="hljs-string">"script"</span>);
    <span class="hljs-keyword">let</span> sudt_script_dep = CellDep::new_builder().out_point(sudt_out_point).build();

    <span class="hljs-comment">//... more code below</span>
<span class="hljs-comment">//}</span>
</code></pre>
<ul>
<li>Build inputs and outputs according to the <code>inputs_token</code> and <code>outputs_token</code></li>
</ul>
<pre><code class="hljs css language-rust"><span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// prepare inputs</span>
    <span class="hljs-comment">// assign 1000 Bytes to per input</span>
    <span class="hljs-keyword">let</span> input_ckb = Capacity::bytes(<span class="hljs-number">1000</span>).unwrap().as_u64();
    <span class="hljs-keyword">let</span> inputs = inputs_token.iter().map(|token| {
        <span class="hljs-keyword">let</span> input_out_point = context.create_cell(
            CellOutput::new_builder()
                .capacity(input_ckb.pack())
                .lock(lock_script.clone())
                .type_(<span class="hljs-literal">Some</span>(sudt_script.clone()).pack())
                .build(),
            token.to_le_bytes().to_vec().into(),
        );
        <span class="hljs-keyword">let</span> input = CellInput::new_builder()
            .previous_output(input_out_point)
            .build();
        input
    });

    <span class="hljs-comment">// prepare outputs</span>
    <span class="hljs-keyword">let</span> output_ckb = input_ckb * inputs_token.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u64</span> / outputs_token.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u64</span>;
    <span class="hljs-keyword">let</span> outputs = outputs_token.iter().map(|_token| {
        CellOutput::new_builder()
            .capacity(output_ckb.pack())
            .lock(lock_script.clone())
            .type_(<span class="hljs-literal">Some</span>(sudt_script.clone()).pack())
            .build()
    });
    <span class="hljs-keyword">let</span> outputs_data: <span class="hljs-built_in">Vec</span>&lt;_&gt; = outputs_token
        .iter()
        .map(|token| Bytes::from(token.to_le_bytes().to_vec()))
        .collect();
    <span class="hljs-comment">// ...</span>
</code></pre>
<ul>
<li>Finally construct the transaction and return it with context.</li>
</ul>
<pre><code class="hljs"><span class="hljs-comment">// build transaction</span>
    <span class="hljs-keyword">let</span> tx = TransactionBuilder::default<span class="hljs-literal">()</span>
        .inputs(inputs)
        .outputs(outputs)
        .outputs<span class="hljs-constructor">_data(<span class="hljs-params">outputs_data</span>.<span class="hljs-params">pack</span>()</span>)
        .cell<span class="hljs-constructor">_dep(<span class="hljs-params">lock_script_dep</span>)</span>
        .cell<span class="hljs-constructor">_dep(<span class="hljs-params">sudt_script_dep</span>)</span>
        .build<span class="hljs-literal">()</span>;
    (context, tx)
</code></pre>
<p>Now the helper function <code>build_test_context</code> is finished, we can write our tests:</p>
<pre><code class="hljs css language-rust"><span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_basic</span></span>() {
    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> context, tx) = build_test_context(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1000</span>], <span class="hljs-built_in">vec!</span>[<span class="hljs-number">400</span>, <span class="hljs-number">600</span>], <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">let</span> tx = context.complete_tx(tx);

    <span class="hljs-comment">// run</span>
    context
        .verify_tx(&amp;tx, MAX_CYCLES)
        .expect(<span class="hljs-string">"pass verification"</span>);
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_destroy_udt</span></span>() {
    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> context, tx) = build_test_context(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1000</span>], <span class="hljs-built_in">vec!</span>[<span class="hljs-number">800</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>], <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">let</span> tx = context.complete_tx(tx);

    <span class="hljs-comment">// run</span>
    context
        .verify_tx(&amp;tx, MAX_CYCLES)
        .expect(<span class="hljs-string">"pass verification"</span>);
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_create_sudt_without_owner_mode</span></span>() {
    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> context, tx) = build_test_context(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1000</span>], <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1200</span>], <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">let</span> tx = context.complete_tx(tx);

    <span class="hljs-comment">// run</span>
    <span class="hljs-keyword">let</span> err = context.verify_tx(&amp;tx, MAX_CYCLES).unwrap_err();
    assert_error_eq!(err, ScriptError::ValidationFailure(ERROR_AMOUNT));
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_create_sudt_with_owner_mode</span></span>() {
    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> context, tx) = build_test_context(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1000</span>], <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1200</span>], <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">let</span> tx = context.complete_tx(tx);

    <span class="hljs-comment">// run</span>
    context
        .verify_tx(&amp;tx, MAX_CYCLES)
        .expect(<span class="hljs-string">"pass verification"</span>);
}
</code></pre>
<p>You may refer to <a href="https://github.com/jjyr/my-sudt/blob/master/tests/src/tests.rs">my-sudt tests</a> for the full tests. Run <code>capsule test</code>  all tests will be passed.</p>
<h2><a class="anchor" aria-hidden="true" id="deployment"></a><a href="#deployment" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deployment</h2>
<h3><a class="anchor" aria-hidden="true" id="run-a-dev-chain-and-ckb-cli-1"></a><a href="#run-a-dev-chain-and-ckb-cli-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Run a dev chain and ckb-cli</h3>
<p>You should be running a dev chain and know about how to use <code>ckb-cli</code> to send transactions before deployment.</p>
<h3><a class="anchor" aria-hidden="true" id="deploy"></a><a href="#deploy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deploy</h3>
<ol>
<li><p>Update the deployment configurations</p>
<p>Open  <code>deployment.toml</code> :</p>
<ul>
<li><p><code>cells</code>  describes which cells to be deployed.</p>
<ul>
<li><code>name</code>: Define the reference name used in the deployment configuration.</li>
<li><code>enable_type_id</code> : If it is set to <code>true</code> means create a <code>type_id</code> for the cell.</li>
<li><code>location</code> :  Define the script binary path.</li>
</ul></li>
<li><p><code>dep_groups</code>  describes which dep_groups to be created. Dep Group is a cell which bundles several cells as its members. When a dep group cell is used in <code>cell_deps</code>, it has the same effect as adding all its members into <code>cell_deps</code>. In our case, we don’t need <code>dep_groups</code>.</p></li>
<li><p><code>lock</code>  describes the <code>lock</code> field of the new deployed cells.It is  recommended to set <code>lock</code> to the deployer's address(an address that you can unlock) in the dev chain and in the testnet, which is easier to update the script.</p></li>
</ul></li>
<li><p>Uncomment the configuration file and replace the cell name and location with <code>my-usdt</code>.</p></li>
</ol>
<pre><code class="hljs"><span class="hljs-meta"># [[cells]]</span>
<span class="hljs-meta"># name = "my_cell"</span>
<span class="hljs-meta"># enable_type_id = false</span>
<span class="hljs-meta"># location = { file = "build/release/my_cell" }</span>

<span class="hljs-meta"># # Dep group cells</span>
<span class="hljs-meta"># [[dep_groups]]</span>
<span class="hljs-meta"># name = "my_dep_group"</span>
<span class="hljs-meta"># cells = [</span>
<span class="hljs-meta">#   "my_cell",</span>
<span class="hljs-meta">#   "secp256k1_data"</span>
<span class="hljs-meta"># ]</span>

<span class="hljs-meta"># # Replace with your own lock if you want to unlock deployed cells.</span>
<span class="hljs-meta"># # The deployment code_hash is secp256k1 lock</span>
<span class="hljs-meta"># [lock]</span>
<span class="hljs-meta"># code_hash = "0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8"</span>
<span class="hljs-meta"># args = "0x0000000000000000000000000000000000000000"</span>
<span class="hljs-meta"># hash_type = "type"</span>
</code></pre>
<ol start="3">
<li>Build release version of the script</li>
</ol>
<ul>
<li>The release version of script  doesn’t  include debug symbols which makes the size smaller.</li>
</ul>
<pre><code class="hljs">capsule build <span class="hljs-comment">--release</span>
</code></pre>
<ol start="4">
<li>Deploy the script</li>
</ol>
<pre><code class="hljs">capsule <span class="hljs-keyword">deploy</span> <span class="hljs-params">--address</span> &lt;ckt1.<span class="hljs-string">...</span>&gt;
</code></pre>
<p>If the <code>ckb-cli</code> has been installed and dev-chain RPC is connectable, you will see the <code>deployment plan</code>:</p>
<ul>
<li><code>new_occupied_capacity</code> and <code>total_occupied_capacity</code>  refer how much CKB to store cells and data.</li>
<li><code>txs_fee_capacity</code> refers how much CKB to pay the transaction fee.</li>
</ul>
<pre><code class="hljs"><span class="hljs-attr">Deployment plan:</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">migrated_capacity:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">(CKB)</span>
<span class="hljs-attr">new_occupied_capacity:</span> <span class="hljs-number">33629.0</span> <span class="hljs-string">(CKB)</span>
<span class="hljs-attr">txs_fee_capacity:</span> <span class="hljs-number">0.0001</span> <span class="hljs-string">(CKB)</span>
<span class="hljs-attr">total_occupied_capacity:</span> <span class="hljs-number">33629.0</span> <span class="hljs-string">(CKB)</span>
<span class="hljs-attr">recipe:</span>
  <span class="hljs-attr">cells:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-sudt</span>
      <span class="hljs-attr">index:</span> <span class="hljs-number">0</span>
      <span class="hljs-attr">tx_hash:</span> <span class="hljs-number">0x8b496cb19018c475cdc4605ee9cef83cbfe578dce4f81f3367395906eba52c29</span>
      <span class="hljs-attr">occupied_capacity:</span> <span class="hljs-number">33629.0</span> <span class="hljs-string">(CKB)</span>
      <span class="hljs-attr">data_hash:</span> <span class="hljs-number">0xaa3d472025e6afefdf3f65c5f9beefd206b4283b30551baef83cbb4762e6d397</span>
      <span class="hljs-attr">type_id:</span> <span class="hljs-string">~</span>
  <span class="hljs-attr">dep_groups:</span> <span class="hljs-string">[]</span>
<span class="hljs-string">Confirm</span> <span class="hljs-string">deployment?</span> <span class="hljs-string">(Yes/No)</span>
</code></pre>
<ol start="5">
<li>Type <code>yes</code> or <code>y</code>  and input the password to unlock the account.</li>
</ol>
<pre><code class="hljs">send cell_tx <span class="hljs-number">8</span>b<span class="hljs-number">496</span>cb<span class="hljs-number">19018</span><span class="hljs-keyword">c</span><span class="hljs-number">475</span>cdc<span class="hljs-number">4605</span>ee<span class="hljs-number">9</span>cef<span class="hljs-number">83</span>cbfe<span class="hljs-number">578</span>dce<span class="hljs-number">4</span>f<span class="hljs-number">81</span>f<span class="hljs-number">3367395906</span>eba<span class="hljs-number">52</span><span class="hljs-keyword">c</span><span class="hljs-number">29</span>
Deployment complete
</code></pre>
<p>Now the SUDT script has been deployed, you can refer to this script by using <code>tx_hash: 0xaa3d472025e6afefdf3f65c5f9beefd206b4283b30551baef83cbb4762e6d397 index: 0</code> as <code>out_point</code>(your <code>tx_hash</code> should be another value).</p>
<h3><a class="anchor" aria-hidden="true" id="migration"></a><a href="#migration" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Migration</h3>
<p>If you want to update the script code and deploy again, you can simply run this command again:</p>
<pre><code class="hljs">capsule <span class="hljs-keyword">deploy</span> <span class="hljs-params">--address</span> ckt1qyq075y5ctzlgahu8pgsqxrqnglajgwa9zksmqdupd
</code></pre>
<p>The new script will be automatically migrated which means destroy the old script cells and create new cells.
You will find  <code>new_occupied_capacity</code> is <code>0</code> because <code>capacity</code> is already covered by the old script cells.Please don’t forget the transaction fee you still need to pay it.</p>
<pre><code class="hljs"><span class="hljs-attr">Deployment plan:</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">migrated_capacity:</span> <span class="hljs-number">33629.0</span> <span class="hljs-string">(CKB)</span>
<span class="hljs-attr">new_occupied_capacity:</span> <span class="hljs-number">0.0</span> <span class="hljs-string">(CKB)</span>
<span class="hljs-attr">txs_fee_capacity:</span> <span class="hljs-number">0.0001</span> <span class="hljs-string">(CKB)</span>
<span class="hljs-attr">total_occupied_capacity:</span> <span class="hljs-number">33629.0</span> <span class="hljs-string">(CKB)</span>
<span class="hljs-attr">recipe:</span>
  <span class="hljs-attr">cells:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">my-sudt</span>
      <span class="hljs-attr">index:</span> <span class="hljs-number">0</span>
      <span class="hljs-attr">tx_hash:</span> <span class="hljs-number">0x10d508a0b44d3c1e02982f85a3e9b5d23d3961fddbf554d20abb4bf54f61950a</span>
      <span class="hljs-attr">occupied_capacity:</span> <span class="hljs-number">33629.0</span> <span class="hljs-string">(CKB)</span>
      <span class="hljs-attr">data_hash:</span> <span class="hljs-number">0xaa3d472025e6afefdf3f65c5f9beefd206b4283b30551baef83cbb4762e6d397</span>
      <span class="hljs-attr">type_id:</span> <span class="hljs-string">~</span>
  <span class="hljs-attr">dep_groups:</span> <span class="hljs-string">[]</span>
<span class="hljs-string">Confirm</span> <span class="hljs-string">deployment?</span> <span class="hljs-string">(Yes/No)</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="next-steps"></a><a href="#next-steps" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Next Steps</h2>
<p>This is the end of our journey into writing a SUDT script by Capsule. We have launched the <a href="https://www.nervos.org/grants/">Nervos Grants Program</a> and <a href="https://medium.com/nervosnetwork/introducing-cklabs-the-nervos-incubator-3e5a2c443c7c">CKLabs</a> to empower innovation and development and support the growth of a diverse and thriving ecosystem. We can't wait to see what you build next!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/labs/introduction"><span class="arrow-prev">← </span><span>Introduction</span></a><a class="docs-next button" href="/docs/labs/lumos-nervosdao"><span class="function-name-prevnext">Introduction to Lumos via NervosDAO</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction">Introduction</a></li><li><a href="#prepare-to-write-the-sudt-script">Prepare to write the SUDT script</a><ul class="toc-headings"><li><a href="#run-a-dev-chain-and-ckb-cli">Run a dev chain and ckb-cli</a></li><li><a href="#install-capsule">Install capsule</a></li><li><a href="#create-a-project">Create a project</a></li><li><a href="#build-the-project">Build the project</a></li></ul></li><li><a href="#write-a-sudt-script">Write a SUDT script</a><ul class="toc-headings"><li><a href="#check-the-used-libraries">Check the used libraries</a></li><li><a href="#load-script">Load Script</a></li><li><a href="#check-inputs">Check inputs</a></li><li><a href="#load-inputs--outputs-udt-amount">Load inputs / outputs UDT amount</a></li><li><a href="#use-iterator-to-query-cells">Use Iterator to query cells</a></li><li><a href="#build-the-project-1">Build the project</a></li></ul></li><li><a href="#testing">Testing</a><ul class="toc-headings"><li><a href="#check-the-default-tests">Check the default tests</a></li><li><a href="#write-new-tests">Write new tests</a></li></ul></li><li><a href="#deployment">Deployment</a><ul class="toc-headings"><li><a href="#run-a-dev-chain-and-ckb-cli-1">Run a dev chain and ckb-cli</a></li><li><a href="#deploy">Deploy</a></li><li><a href="#migration">Migration</a></li></ul></li><li><a href="#next-steps">Next Steps</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><div class="footerSection"><h5>Foundation</h5><a href="https://www.nervos.org/">About Us</a></div><div class="footerSection"><h5>Developer</h5><a href="https://github.com/nervosnetwork">GitHub</a><a href="https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0002-ckb/0002-ckb.md">Whitepaper</a><a href="https://github.com/nervosnetwork/rfcs">RFCs</a></div><div class="footerSection socialLinks"><a href="https://twitter.com/nervosnetwork" class="socialLink"><img src="/img/footer_twitter.png"/>Twitter</a><a href="https://medium.com/nervosnetwork" class="socialLink"><img src="/img/footer_medium.png"/>Blog</a><a href="https://t.me/nervosnetwork" class="socialLink"><img src="/img/footer_telegram.png"/>Telegram</a><a href="https://www.reddit.com/r/NervosNetwork/" class="socialLink"><img src="/img/footer_reddit.png"/>Reddit</a><a href="https://www.youtube.com/channel/UCONuJGdMzUY0Y6jrPBOzH7A" class="socialLink"><img src="/img/footer_youtube.png"/>YouTube</a><a href="https://talk.nervos.org/" class="socialLink"><img src="/img/footer_forum.png"/>Forum</a></div></section><section class="copyright"><span>Copyright © 2020  Nervos Foundation. All Rights Reserved.</span></section></footer><div id="oldSiteLink"><div><span>Note we&#x27;ve completely rebuilt Nervos Doc site! </span><span>For the old doc site, please see <a href="https://docs-old.nervos.org">docs-old</a>.</span></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '4ca49bc7433bcef238e8b9aab6dc4d11',
                indexName: 'nervos_ckbd',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>